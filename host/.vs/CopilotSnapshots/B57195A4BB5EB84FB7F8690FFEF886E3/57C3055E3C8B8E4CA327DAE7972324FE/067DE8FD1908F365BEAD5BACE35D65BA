#pragma once

#include <cstdint>
#include <array>
#include <string>
#include <vector>
#include <nlohmann/json.hpp>

namespace TabDisplay {

// Constants
constexpr uint16_t MAX_CHUNK_SIZE = 1350;
constexpr uint16_t HEADER_SIZE = 12;
constexpr uint32_t FLAG_KEYFRAME = 1;
constexpr uint32_t FLAG_INPUT_PACKET = 2;
constexpr uint32_t FLAG_CONTROL_PACKET = 4;
constexpr uint16_t KEEPALIVE_INTERVAL = 60; // frames

// Packet header structure (12 bytes)
struct PacketHeader {
struct PacketHeader {
    uint16_t sequenceId;   // Unique sequence identifier
    uint16_t frameId;      // Which frame this chunk belongs to
    uint16_t totalChunks;  // Total chunks in this frame
    uint16_t chunkIndex;   // Index of this chunk (0-based)
    uint32_t flags;        // Bit flags (keyframe, input packet, etc.)

    // Serialize header to binary
    std::array<uint8_t, HEADER_SIZE> serialize() const {
        std::array<uint8_t, HEADER_SIZE> buffer;
        
        buffer[0] = static_cast<uint8_t>(sequenceId & 0xFF);
        buffer[1] = static_cast<uint8_t>((sequenceId >> 8) & 0xFF);
        
        buffer[2] = static_cast<uint8_t>(frameId & 0xFF);
        buffer[3] = static_cast<uint8_t>((frameId >> 8) & 0xFF);
        
        buffer[4] = static_cast<uint8_t>(totalChunks & 0xFF);
        buffer[5] = static_cast<uint8_t>((totalChunks >> 8) & 0xFF);
        
        buffer[6] = static_cast<uint8_t>(chunkIndex & 0xFF);
        buffer[7] = static_cast<uint8_t>((chunkIndex >> 8) & 0xFF);
        
        buffer[8] = static_cast<uint8_t>(flags & 0xFF);
        buffer[9] = static_cast<uint8_t>((flags >> 8) & 0xFF);
        buffer[10] = static_cast<uint8_t>((flags >> 16) & 0xFF);
        buffer[11] = static_cast<uint8_t>((flags >> 24) & 0xFF);
        
        return buffer;
    }

    // Deserialize header from binary
    static PacketHeader deserialize(const uint8_t* data) {
        PacketHeader header;
        
        header.sequenceId = static_cast<uint16_t>(data[0]) | 
                            (static_cast<uint16_t>(data[1]) << 8);
        
        header.frameId = static_cast<uint16_t>(data[2]) | 
                        (static_cast<uint16_t>(data[3]) << 8);
        
        header.totalChunks = static_cast<uint16_t>(data[4]) | 
                            (static_cast<uint16_t>(data[5]) << 8);
        
        header.chunkIndex = static_cast<uint16_t>(data[6]) | 
                            (static_cast<uint16_t>(data[7]) << 8);
        
        header.flags = static_cast<uint32_t>(data[8]) | 
                      (static_cast<uint32_t>(data[9]) << 8) |
                      (static_cast<uint32_t>(data[10]) << 16) |
                      (static_cast<uint32_t>(data[11]) << 24);
        
        return header;
    }
};

// Control packet structure (sent every KEEPALIVE_INTERVAL frames)
struct ControlPacket {
    std::string type;
    uint32_t width;
    uint32_t height;
    uint32_t fps;
    uint32_t bitrate;

    // Serialize to JSON
    nlohmann::json toJson() const {
        return {
            {"type", type},
            {"width", width},
            {"height", height},
            {"fps", fps},
            {"bitrate", bitrate}
        };
    }

    // Deserialize from JSON
    static ControlPacket fromJson(const nlohmann::json& j) {
        ControlPacket packet;
        packet.type = j.at("type").get<std::string>();
        packet.width = j.at("width").get<uint32_t>();
        packet.height = j.at("height").get<uint32_t>();
        packet.fps = j.at("fps").get<uint32_t>();
        packet.bitrate = j.at("bitrate").get<uint32_t>();
        return packet;
    }
};

// Touch input packet structure (received from Android client)
struct TouchInputPacket {
    enum class Action {
        DOWN = 0,
        MOVE = 1,
        UP = 2
    };

    Action action;
    uint32_t x;
    uint32_t y;
    uint32_t pointerId;

    // Deserialize from JSON
    static TouchInputPacket fromJson(const nlohmann::json& j) {
        TouchInputPacket packet;
        std::string actionStr = j.at("action").get<std::string>();
        
        if (actionStr == "down") packet.action = Action::DOWN;
        else if (actionStr == "move") packet.action = Action::MOVE;
        else if (actionStr == "up") packet.action = Action::UP;
        
        packet.x = j.at("x").get<uint32_t>();
        packet.y = j.at("y").get<uint32_t>();
        packet.pointerId = j.at("pointerId").get<uint32_t>();
        
        return packet;
    }
};

// Helper functions

// Split frame data into chunks and add headers
std::vector<std::vector<uint8_t>> createPackets(const std::vector<uint8_t>& frameData, 
                                               uint16_t frameId, uint16_t sequenceIdStart,
                                               bool isKeyFrame) {
    std::vector<std::vector<uint8_t>> packets;
    const size_t totalChunks = (frameData.size() + MAX_CHUNK_SIZE - 1) / MAX_CHUNK_SIZE;
    
    for (size_t i = 0; i < totalChunks; ++i) {
        PacketHeader header;
        header.sequenceId = sequenceIdStart + static_cast<uint16_t>(i);
        header.frameId = frameId;
        header.totalChunks = static_cast<uint16_t>(totalChunks);
        header.chunkIndex = static_cast<uint16_t>(i);
        header.flags = isKeyFrame ? FLAG_KEYFRAME : 0;
        
        auto headerBinary = header.serialize();
        
        std::vector<uint8_t> packetData(HEADER_SIZE + std::min(MAX_CHUNK_SIZE, frameData.size() - i * MAX_CHUNK_SIZE));
        
        // Copy header
        std::copy(headerBinary.begin(), headerBinary.end(), packetData.begin());
        
        // Copy chunk data
        const size_t chunkSize = std::min(MAX_CHUNK_SIZE, frameData.size() - i * MAX_CHUNK_SIZE);
        std::copy(frameData.begin() + i * MAX_CHUNK_SIZE,
                  frameData.begin() + i * MAX_CHUNK_SIZE + chunkSize,
                  packetData.begin() + HEADER_SIZE);
        
        packets.push_back(std::move(packetData));
    }
    
    return packets;
}

// Create a keepalive control packet
std::vector<uint8_t> createControlPacket(uint16_t sequenceId, uint32_t width, uint32_t height, 
                                        uint32_t fps, uint32_t bitrate) {
    ControlPacket control;
    control.type = "keepalive";
    control.width = width;
    control.height = height;
    control.fps = fps;
    control.bitrate = bitrate;
    
    // Create JSON payload
    std::string jsonStr = control.toJson().dump();
    std::vector<uint8_t> jsonData(jsonStr.begin(), jsonStr.end());
    
    // Create header
    PacketHeader header;
    header.sequenceId = sequenceId;
    header.frameId = 0;  // Control packets don't belong to any frame
    header.totalChunks = 1;
    header.chunkIndex = 0;
    header.flags = FLAG_CONTROL_PACKET;
    
    auto headerBinary = header.serialize();
    
    // Combine header and payload
    std::vector<uint8_t> packet(HEADER_SIZE + jsonData.size());
    std::copy(headerBinary.begin(), headerBinary.end(), packet.begin());
    std::copy(jsonData.begin(), jsonData.end(), packet.begin() + HEADER_SIZE);
    
    return packet;
}

// Calculate XOR parity chunks for FEC
std::vector<std::vector<uint8_t>> createParityChunks(const std::vector<std::vector<uint8_t>>& dataChunks,
                                                   uint16_t frameId, uint16_t sequenceIdStart) {
    // We'll create 2 parity chunks based on specification
    std::vector<std::vector<uint8_t>> parityChunks(2);
    
    if (dataChunks.empty()) {
        return parityChunks;
    }
    
    // Find the maximum chunk size
    size_t maxChunkSize = 0;
    for (const auto& chunk : dataChunks) {
        maxChunkSize = std::max(maxChunkSize, chunk.size());
    }
    
    // Initialize parity chunks with zeros
    parityChunks[0].resize(maxChunkSize, 0);
    parityChunks[1].resize(maxChunkSize, 0);
    
    // Simple XOR-based FEC:
    // parity[0] = XOR of even-indexed chunks
    // parity[1] = XOR of odd-indexed chunks
    for (size_t i = 0; i < dataChunks.size(); ++i) {
        const auto& chunk = dataChunks[i];
        auto& parityChunk = parityChunks[i % 2];
        
        for (size_t j = 0; j < chunk.size(); ++j) {
            parityChunk[j] ^= chunk[j];
        }
    }
    
    // Create headers for parity chunks
    for (size_t i = 0; i < parityChunks.size(); ++i) {
        PacketHeader header;
        header.sequenceId = sequenceIdStart + static_cast<uint16_t>(dataChunks.size() + i);
        header.frameId = frameId;
        header.totalChunks = static_cast<uint16_t>(dataChunks.size());
        header.chunkIndex = static_cast<uint16_t>(0xF000 + i);  // Special marker for parity chunks
        header.flags = 0;
        
        auto headerBinary = header.serialize();
        
        // Replace the header part of parity chunks
        std::copy(headerBinary.begin(), headerBinary.end(), parityChunks[i].begin());
    }
    
    return parityChunks;
}

} // namespace TabDisplay