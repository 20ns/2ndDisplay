#pragma once

#include <vector>
#include <cstdint>
#include <stdexcept>
#include <algorithm>

namespace FEC {

// Simple XOR-based Forward Error Correction
class XorFEC {
public:
    // Generate parity data for a set of data chunks
    // Returns a vector of parity chunks (2 for this implementation)
    static std::vector<std::vector<uint8_t>> GenerateParityChunks(
        const std::vector<std::vector<uint8_t>>& dataChunks) {
        
        if (dataChunks.empty()) {
            throw std::invalid_argument("Data chunks vector is empty");
        }
        
        // Find the maximum chunk size
        size_t maxChunkSize = 0;
        for (const auto& chunk : dataChunks) {
            maxChunkSize = std::max(maxChunkSize, chunk.size());
        }
        
        // Create two parity chunks
        // parity[0] = XOR of even-indexed chunks (0, 2, 4, ...)
        // parity[1] = XOR of odd-indexed chunks (1, 3, 5, ...)
        std::vector<std::vector<uint8_t>> parityChunks(2);
        parityChunks[0].resize(maxChunkSize, 0);
        parityChunks[1].resize(maxChunkSize, 0);
        
        for (size_t i = 0; i < dataChunks.size(); ++i) {
            const auto& chunk = dataChunks[i];
            auto& parityChunk = parityChunks[i % 2];
            
            for (size_t j = 0; j < chunk.size(); ++j) {
                parityChunk[j] ^= chunk[j];
            }
        }
        
        return parityChunks;
    }
    
    // Recover lost chunks using parity data
    // lostChunkIndices contains the indices of lost chunks (maximum 2)
    // Returns a vector of recovered chunks in the order of lostChunkIndices
    static std::vector<std::vector<uint8_t>> RecoverChunks(
        const std::vector<std::vector<uint8_t>>& availableChunks,
        const std::vector<std::vector<uint8_t>>& parityChunks,
        const std::vector<size_t>& lostChunkIndices,
        size_t totalChunks) {
        
        if (lostChunkIndices.size() > 2) {
            throw std::invalid_argument("Cannot recover more than 2 lost chunks");
        }
        
        if (lostChunkIndices.empty()) {
            return {};  // Nothing to recover
        }
        
        // Group lost chunks by parity group (even/odd)
        std::vector<size_t> evenLostChunks;
        std::vector<size_t> oddLostChunks;
        
        for (size_t lostIndex : lostChunkIndices) {
            if (lostIndex % 2 == 0) {
                evenLostChunks.push_back(lostIndex);
            } else {
                oddLostChunks.push_back(lostIndex);
            }
        }
        
        // Find the maximum chunk size
        size_t maxChunkSize = parityChunks[0].size();
        for (const auto& chunk : availableChunks) {
            maxChunkSize = std::max(maxChunkSize, chunk.size());
        }
        
        std::vector<std::vector<uint8_t>> recoveredChunks;
        
        // Recover even-indexed chunks if there's exactly one lost
        if (evenLostChunks.size() == 1) {
            std::vector<uint8_t> recoveredChunk(maxChunkSize, 0);
            
            // Start with the even parity chunk
            std::copy(parityChunks[0].begin(), parityChunks[0].end(), recoveredChunk.begin());
            
            // XOR with all available even-indexed chunks
            for (size_t i = 0; i < totalChunks; ++i) {
                if (i % 2 == 0 && i != evenLostChunks[0]) {
                    // Find this chunk in availableChunks
                    for (const auto& chunk : availableChunks) {
                        // Use the first chunk that matches our index
                        // In a real implementation, we'd have a better way to identify chunks
                        if (chunk.size() >= sizeof(size_t) && *reinterpret_cast<const size_t*>(chunk.data()) == i) {
                            for (size_t j = 0; j < chunk.size() && j < recoveredChunk.size(); ++j) {
                                recoveredChunk[j] ^= chunk[j];
                            }
                            break;
                        }
                    }
                }
            }
            
            recoveredChunks.push_back(std::move(recoveredChunk));
        }
        
        // Recover odd-indexed chunks if there's exactly one lost
        if (oddLostChunks.size() == 1) {
            std::vector<uint8_t> recoveredChunk(maxChunkSize, 0);
            
            // Start with the odd parity chunk
            std::copy(parityChunks[1].begin(), parityChunks[1].end(), recoveredChunk.begin());
            
            // XOR with all available odd-indexed chunks
            for (size_t i = 0; i < totalChunks; ++i) {
                if (i % 2 == 1 && i != oddLostChunks[0]) {
                    // Find this chunk in availableChunks
                    for (const auto& chunk : availableChunks) {
                        // Use the first chunk that matches our index
                        if (chunk.size() >= sizeof(size_t) && *reinterpret_cast<const size_t*>(chunk.data()) == i) {
                            for (size_t j = 0; j < chunk.size() && j < recoveredChunk.size(); ++j) {
                                recoveredChunk[j] ^= chunk[j];
                            }
                            break;
                        }
                    }
                }
            }
            
            recoveredChunks.push_back(std::move(recoveredChunk));
        }
        
        return recoveredChunks;
    }
};

} // namespace FEC